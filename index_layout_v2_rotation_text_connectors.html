<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Layout Designer v2 – Rotación, Texto y Conectores</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body, #root { height: 100%; }
    .handle { box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
    .cursor-rotate { cursor: grab; }
    .cursor-rotate:active { cursor: grabbing; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="react">
    const { useEffect, useMemo, useRef, useState } = React;

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const uid = () => Math.random().toString(36).slice(2, 9);

    const DEFAULT_SCALE_PX_PER_M = 120;
    const DEFAULT_GRID_STEP_M = 0.1;
    const UNIT_META = {
      m: { label: "m", toBase: (v) => v, fromBase: (v) => v },
      cm: { label: "cm", toBase: (v) => v / 100, fromBase: (v) => v * 100 },
    };

    const SHAPE_TYPES = { rect: { label: "Rectangle" }, circle: { label: "Circle" }, text: { label: "Text" } };

    function Section({ title, children }) {
      return (
        <div className="mb-4 p-3 rounded-2xl border bg-white shadow-sm">
          <div className="font-semibold text-gray-800">{title}</div>
          <div className="mt-3">{children}</div>
        </div>
      );
    }

    function formatLen(v) {
      const isIntish = Math.abs(v - Math.round(v)) < 1e-6;
      return isIntish ? `${Math.round(v)}` : v.toFixed(2);
    }

    function deg(rad){ return rad * 180 / Math.PI; }
    function rad(deg){ return deg * Math.PI / 180; }

    // ---------- Shapes (Rect, Circle, Text) ----------
    function Shape({ shape, selected, unitLabel, sizePxToUnit, onMouseDown, onRotateDown }) {
      const { type, x, y, w, h, fill, opacity, label, rotation, text, fontSize, textColor, bg } = shape;

      const rotateHandle = (
        <div
          className="absolute -top-6 left-1/2 -translate-x-1/2 h-4 w-4 rounded-full bg-white border handle cursor-rotate"
          onMouseDown={(e) => onRotateDown(e, shape.id)}
          title="Rotar"
        ></div>
      );

      if (type === "rect") {
        const dimsText = `${formatLen(sizePxToUnit(w))} ${unitLabel} × ${formatLen(sizePxToUnit(h))} ${unitLabel}`;
        return (
          <div
            className={`absolute group select-none ${selected ? "ring-2 ring-indigo-500" : "ring-1 ring-gray-300"}`}
            style={{
              left: x, top: y, width: w, height: h,
              backgroundColor: fill, opacity, borderRadius: 8,
              transform: `rotate(${rotation||0}deg)`, transformOrigin: "top left"
            }}
            onMouseDown={(e) => onMouseDown(e, "move")}
          >
            {rotateHandle}
            <div className="absolute -top-7 left-0 px-2 py-0.5 text-xs rounded-md bg-white/90 border shadow">
              <div className="font-medium">{label}</div>
              <div className="text-[10px] text-gray-600">{dimsText}</div>
            </div>
            <div
              className="absolute -bottom-2 -right-2 h-4 w-4 rounded-full bg-white border shadow cursor-nwse-resize opacity-0 group-hover:opacity-100 handle"
              onMouseDown={(e) => onMouseDown(e, "resize")}
              title="Redimensionar"
            />
          </div>
        );
      }

      if (type === "circle") {
        const size = Math.min(w, h);
        return (
          <div
            className={`absolute group select-none ${selected ? "ring-2 ring-indigo-500" : "ring-1 ring-gray-300"}`}
            style={{
              left: x, top: y, width: size, height: size,
              backgroundColor: fill, opacity, borderRadius: "9999px",
              transform: `rotate(${rotation||0}deg)`, transformOrigin: "top left"
            }}
            onMouseDown={(e) => onMouseDown(e, "move")}
          >
            {rotateHandle}
            <div className="absolute -top-7 left-0 px-2 py-0.5 text-xs rounded-md bg-white/90 border shadow">
              <div className="font-medium">{label}</div>
              <div className="text-[10px] text-gray-600">Ø {formatLen(sizePxToUnit(size))} {unitLabel}</div>
            </div>
            <div
              className="absolute -bottom-2 -right-2 h-4 w-4 rounded-full bg-white border shadow cursor-nwse-resize opacity-0 group-hover:opacity-100 handle"
              onMouseDown={(e) => onMouseDown(e, "resize")}
              title="Redimensionar"
            />
          </div>
        );
      }

      if (type === "text") {
        return (
          <div
            className={`absolute ${selected ? "ring-2 ring-indigo-500" : "ring-1 ring-gray-300"} select-none`}
            style={{
              left: x, top: y, width: w, height: h,
              backgroundColor: bg || "transparent", padding: "6px 8px", borderRadius: 6,
              transform: `rotate(${rotation||0}deg)`, transformOrigin: "top left"
            }}
            onMouseDown={(e) => onMouseDown(e, "move")}
          >
            {rotateHandle}
            <div style={{ color: textColor || "#111", fontSize: (fontSize||16) }} className="leading-snug">
              {text || "Área / Texto"}
            </div>
            <div
              className="absolute -bottom-2 -right-2 h-4 w-4 rounded-full bg-white border shadow cursor-nwse-resize opacity-100 handle"
              onMouseDown={(e) => onMouseDown(e, "resize")}
              title="Redimensionar"
            />
          </div>
        );
      }
      return null;
    }

    // ---------- Connectors (SVG lines/arrows) ----------
    function ConnectorsLayer({ connectors, selectedId, onSelect, onDragEndpointStart, dashArray }){
      return (
        <svg className="absolute inset-0 pointer-events-none" style={{ overflow:"visible" }}>
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="currentColor"></path>
            </marker>
          </defs>
          {connectors.map(c => (
            <g key={c.id} className="pointer-events-auto">
              <line x1={c.x1} y1={c.y1} x2={c.x2} y2={c.y2}
                    stroke="currentColor"
                    strokeWidth={c.strokeWidth||2}
                    strokeDasharray={c.dashed ? "6 6" : undefined}
                    markerEnd={c.arrow ? "url(#arrow)" : undefined}
                    className={selectedId===c.id ? "text-indigo-600" : "text-gray-700"}
                    onMouseDown={(e)=>{ e.stopPropagation(); onSelect(c.id); }}
              />
              {/* Endpoint handles */}
              <circle cx={c.x1} cy={c.y1} r="6" fill="#fff" stroke={selectedId===c.id ? "#4f46e5":"#999"} className="handle cursor-move"
                      onMouseDown={(e)=>onDragEndpointStart(e, c.id, "a")} />
              <circle cx={c.x2} cy={c.y2} r="6" fill="#fff" stroke={selectedId===c.id ? "#4f46e5":"#999"} className="handle cursor-move"
                      onMouseDown={(e)=>onDragEndpointStart(e, c.id, "b")} />
            </g>
          ))}
        </svg>
      );
    }

    function App() {
      // Units / grid
      const [unit, setUnit] = useState("m");
      const [scalePxPerM, setScalePxPerM] = useState(DEFAULT_SCALE_PX_PER_M);
      const [gridStepM, setGridStepM] = useState(DEFAULT_GRID_STEP_M);
      const [snap, setSnap] = useState(true);

      // Shapes & selection
      const [shapes, setShapes] = useState([]);
      const [connectors, setConnectors] = useState([]);
      const [selectedId, setSelectedId] = useState(null);
      const [selectedKind, setSelectedKind] = useState(null); // "shape" | "connector"

      // Pan
      const [pan, setPan] = useState({ x: 0, y: 0 });
      const panRef = useRef(pan); useEffect(()=>{ panRef.current = pan; }, [pan]);

      const canvasRef = useRef(null);

      const unitLabel = UNIT_META[unit].label;
      const unitToMeters = UNIT_META[unit].toBase;
      const metersToUnit = UNIT_META[unit].fromBase;
      const gridStepInPx = gridStepM * scalePxPerM;
      const sizeUnitToPx = (valInUnit) => unitToMeters(valInUnit) * scalePxPerM;
      const sizePxToUnit = (px) => metersToUnit(px / scalePxPerM);
      const snapPx = (px) => (snap ? Math.round(px / gridStepInPx) * gridStepInPx : px);

      // Adders
      const addShape = (type) => {
        const id = uid();
        if (type === "text"){
          const sh = { id, type:"text", x:120, y:120, w:180, h:50, label:"Etiqueta", text:"Área", fontSize:18, textColor:"#111", bg:"rgba(255,255,255,0.8)", rotation:0 };
          setShapes(s=>[...s, sh]); setSelectedKind("shape"); setSelectedId(id); return;
        }
        const baseWUnit = unit === "m" ? 1 : 100;
        const baseHUnit = unit === "m" ? 0.6 : 60;
        const newShape = {
          id, type, x: 100, y: 100,
          w: sizeUnitToPx(baseWUnit), h: sizeUnitToPx(baseHUnit),
          fill: "#4f46e5", opacity: 0.85,
          label: type === "rect" ? "Mesa" : "Pilar", rotation: 0,
        };
        setShapes((s) => [...s, newShape]);
        setSelectedKind("shape"); setSelectedId(id);
      };

      const addConnector = ({ arrow=false, dashed=false }) => {
        const id = uid();
        const c = { id, x1: 200, y1: 200, x2: 320, y2: 240, arrow, dashed, strokeWidth: 2 };
        setConnectors(cs => [...cs, c]);
        setSelectedKind("connector"); setSelectedId(id);
      };

      const updateShape = (id, patch) => setShapes((s) => s.map((sh) => (sh.id === id ? { ...sh, ...patch } : sh)));
      const updateConnector = (id, patch) => setConnectors((cs)=> cs.map(c => c.id===id ? { ...c, ...patch } : c));

      const deleteSelected = () => {
        if (!selectedId) return;
        if (selectedKind === "shape") setShapes((s) => s.filter((sh) => sh.id !== selectedId));
        if (selectedKind === "connector") setConnectors(cs => cs.filter(c => c.id !== selectedId));
        setSelectedId(null); setSelectedKind(null);
      };

      // Drag logic shapes
      const dragState = useRef({ dragging: false, id: null, offsetX: 0, offsetY: 0, mode: "move" });
      const rotateState = useRef({ rotating: false, id: null, startAngle: 0, startRotation: 0, origin: {x:0,y:0} });

      const onMouseDownShape = (e, id, mode = "move") => {
        e.stopPropagation();
        const rect = canvasRef.current.getBoundingClientRect();
        const sh = shapes.find((s) => s.id === id);
        const mouseX = e.clientX - rect.left - pan.x;
        const mouseY = e.clientY - rect.top - pan.y;
        dragState.current = { dragging: true, id, mode, offsetX: mouseX - sh.x, offsetY: mouseY - sh.y };
        setSelectedId(id); setSelectedKind("shape");
      };

      const onRotateDown = (e, id) => {
        e.stopPropagation();
        const rect = canvasRef.current.getBoundingClientRect();
        const sh = shapes.find(s=>s.id===id);
        const origin = { x: sh.x, y: sh.y };
        const mx = e.clientX - rect.left - pan.x;
        const my = e.clientY - rect.top - pan.y;
        const angle = Math.atan2(my - origin.y, mx - origin.x);
        rotateState.current = { rotating:true, id, startAngle: angle, startRotation: (sh.rotation||0), origin };
        setSelectedId(id); setSelectedKind("shape");
      };

      // Drag logic connectors
      const connDrag = useRef({ dragging:false, id:null, end:null }); // end: "a" | "b"
      const onDragEndpointStart = (e, id, end) => {
        e.stopPropagation();
        connDrag.current = { dragging:true, id, end };
        setSelectedId(id); setSelectedKind("connector");
      };

      const onMouseDownCanvas = (e) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
          const rect = canvasRef.current.getBoundingClientRect();
          const start = { x: e.clientX - rect.left, y: e.clientY - rect.top };
          const startPan = { ...panRef.current };
          const onMove = (ev) => setPan({ x: startPan.x + (ev.clientX - rect.left - start.x), y: startPan.y + (ev.clientY - rect.top - start.y) });
          const onUp = () => { window.removeEventListener("mousemove", onMove); window.removeEventListener("mouseup", onUp); };
          window.addEventListener("mousemove", onMove); window.addEventListener("mouseup", onUp);
          return;
        }
        setSelectedId(null); setSelectedKind(null);
      };

      useEffect(() => {
        const onMove = (e) => {
          const rect = canvasRef.current.getBoundingClientRect();
          const mx = e.clientX - rect.left - panRef.current.x;
          const my = e.clientY - rect.top - panRef.current.y;

          // rotate
          if (rotateState.current.rotating){
            const { id, startAngle, startRotation, origin } = rotateState.current;
            const currentAngle = Math.atan2(my - origin.y, mx - origin.x);
            const delta = deg(currentAngle - startAngle);
            updateShape(id, { rotation: startRotation + delta });
            return;
          }

          // drag connectors
          if (connDrag.current.dragging){
            const { id, end } = connDrag.current;
            const pos = { x: snapPx(mx), y: snapPx(my) };
            if (end==="a") updateConnector(id, { x1: pos.x, y1: pos.y });
            if (end==="b") updateConnector(id, { x2: pos.x, y2: pos.y });
            return;
          }

          // drag shapes
          if (!dragState.current.dragging) return;
          const { id, offsetX, offsetY, mode } = dragState.current;
          setShapes((prev) =>
            prev.map((sh) => {
              if (sh.id !== id) return sh;
              if (mode === "move") {
                const nx = snapPx(mx - offsetX);
                const ny = snapPx(my - offsetY);
                return { ...sh, x: nx, y: ny };
              } else if (mode === "resize") {
                const nw = clamp(snapPx(mx - sh.x), 20, 5000);
                const nh = clamp(snapPx(my - sh.y), 20, 5000);
                return { ...sh, w: nw, h: nh };
              }
              return sh;
            })
          );
        };
        const onUp = () => {
          dragState.current.dragging = false; dragState.current.id = null;
          rotateState.current.rotating = false; rotateState.current.id = null;
          connDrag.current.dragging = false; connDrag.current.id = null;
        };
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);
        return () => {
          window.removeEventListener("mousemove", onMove);
          window.removeEventListener("mouseup", onUp);
        };
      }, [gridStepInPx]);

      const gridBackground = useMemo(() => {
        const s = gridStepInPx; const big = s * 5;
        return {
          backgroundImage: `
            linear-gradient(to right, rgba(0,0,0,0.08) 1px, transparent 1px),
            linear-gradient(to bottom, rgba(0,0,0,0.08) 1px, transparent 1px),
            linear-gradient(to right, rgba(0,0,0,0.18) 1px, transparent 1px),
            linear-gradient(to bottom, rgba(0,0,0,0.18) 1px, transparent 1px)
          `,
          backgroundSize: `${s}px ${s}px, ${s}px ${s}px, ${big}px ${big}px, ${big}px ${big}px`,
          backgroundPosition: `${pan.x}px ${pan.y}px, ${pan.x}px ${pan.y}px, ${pan.x}px ${pan.y}px, ${pan.x}px ${pan.y}px`,
        };
      }, [gridStepInPx, pan]);

      const selectedShape = (selectedKind==="shape") ? shapes.find(s=>s.id===selectedId) : null;
      const selectedConnector = (selectedKind==="connector") ? connectors.find(c=>c.id===selectedId) : null;

      return (
        <div className="h-screen w-full bg-gray-50 text-gray-900">
          <div className="flex items-center justify-between px-4 py-3 border-b bg-white sticky top-0 z-10">
            <div className="flex items-center gap-2">
              <div className="text-lg font-semibold">Layout Designer v2</div>
              <div className="text-xs text-gray-500">(m/cm, rotación, texto y conectores)</div>
            </div>
            <div className="flex items-center gap-2">
              <button onClick={() => addShape("rect")} className="px-3 py-2 rounded-xl bg-gray-900 text-white hover:bg-black shadow">+ Rectángulo</button>
              <button onClick={() => addShape("circle")} className="px-3 py-2 rounded-xl bg-gray-900 text-white hover:bg-black shadow">+ Círculo</button>
              <button onClick={() => addShape("text")} className="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-gray-50">+ Texto</button>
              <div className="h-6 w-px bg-gray-200" />
              <button onClick={() => addConnector({arrow:false,dashed:false})} className="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-gray-50">— Línea</button>
              <button onClick={() => addConnector({arrow:true,dashed:false})} className="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-gray-50">→ Flecha</button>
              <button onClick={() => addConnector({arrow:false,dashed:true})} className="px-3 py-2 rounded-xl bg-white border shadow-sm hover:bg-gray-50">⋯ Línea punteada</button>
            </div>
          </div>

          <div className="grid grid-cols-[320px_1fr] h-[calc(100vh-56px)]">
            <div className="p-3 border-r bg-white overflow-y-auto">
              <Section title="Unidades & Escala">
                <div className="flex items-center gap-2">
                  <label className={`px-3 py-1 rounded-full border cursor-pointer ${unit === "m" ? "bg-gray-900 text-white" : "bg-white"}`}>
                    <input type="radio" name="unit" className="hidden" checked={unit === "m"} onChange={() => setUnit("m")} />
                    Metros
                  </label>
                  <label className={`px-3 py-1 rounded-full border cursor-pointer ${unit === "cm" ? "bg-gray-900 text-white" : "bg-white"}`}>
                    <input type="radio" name="unit" className="hidden" checked={unit === "cm"} onChange={() => setUnit("cm")} />
                    Centímetros
                  </label>
                </div>
                <div className="mt-3 text-sm">
                  <label className="block text-gray-500">Escala (1 m = px)</label>
                  <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2" min={20} max={800}
                         value={scalePxPerM}
                         onChange={(e) => setScalePxPerM(clamp(Number(e.target.value), 10, 2000))} />
                </div>
                <div className="mt-3 text-sm">
                  <label className="block text-gray-500">Cuadrícula cada</label>
                  <div className="flex items-center gap-2">
                    <input type="number" className="mt-1 w-24 rounded-xl border px-3 py-2"
                           step={unit === "m" ? 0.1 : 1} min={unit === "m" ? 0.05 : 5}
                           value={UNIT_META[unit].fromBase(gridStepM)}
                           onChange={(e) => setGridStepM(UNIT_META[unit].toBase(Number(e.target.value)))} />
                    <span className="text-gray-600">{UNIT_META[unit].label}</span>
                  </div>
                </div>
                <div className="mt-3 flex items-center justify-between">
                  <label className="text-sm text-gray-700">Ajustar a cuadrícula</label>
                  <input type="checkbox" checked={snap} onChange={(e) => setSnap(e.target.checked)} />
                </div>
              </Section>

              <Section title="Elemento seleccionado">
                {!selectedId ? (
                  <div className="text-sm text-gray-500">Selecciona una figura o conector para editar.</div>
                ) : selectedKind === "shape" ? (
                  <div className="space-y-3 text-sm">
                    <div className="flex items-center justify-between">
                      <span className="text-gray-500">Tipo</span>
                      <span className="font-medium">{SHAPE_TYPES[shapes.find(s=>s.id===selectedId).type].label}</span>
                    </div>
                    {(() => {
                      const s = shapes.find(s=>s.id===selectedId);
                      if (!s) return null;
                      return (
                        <>
                          <div>
                            <label className="block text-gray-500">Etiqueta</label>
                            <input className="mt-1 w-full rounded-xl border px-3 py-2"
                                   value={s.label || ""}
                                   onChange={(e) => updateShape(s.id, { label: e.target.value })} />
                          </div>

                          {s.type === "text" ? (
                            <>
                              <div>
                                <label className="block text-gray-500">Texto</label>
                                <input className="mt-1 w-full rounded-xl border px-3 py-2"
                                       value={s.text || ""}
                                       onChange={(e) => updateShape(s.id, { text: e.target.value })} />
                              </div>
                              <div className="grid grid-cols-2 gap-2">
                                <div>
                                  <label className="block text-gray-500">Tamaño fuente</label>
                                  <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                         min={10} max={72} value={s.fontSize || 18}
                                         onChange={(e) => updateShape(s.id, { fontSize: Number(e.target.value) })} />
                                </div>
                                <div>
                                  <label className="block text-gray-500">Color texto</label>
                                  <input type="color" className="mt-1 h-10 w-full rounded-xl border"
                                         value={s.textColor || "#111111"}
                                         onChange={(e) => updateShape(s.id, { textColor: e.target.value })} />
                                </div>
                              </div>
                              <div>
                                <label className="block text-gray-500">Fondo</label>
                                <input type="color" className="mt-1 h-10 w-full rounded-xl border"
                                       value={s.bg || "#ffffffcc"}
                                       onChange={(e) => updateShape(s.id, { bg: e.target.value })} />
                              </div>
                            </>
                          ) : (
                            <div className="grid grid-cols-2 gap-2">
                              <div>
                                <label className="block text-gray-500">Ancho ({UNIT_META[unit].label})</label>
                                <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                       min={unit === "m" ? 0.05 : 5} step={unit === "m" ? 0.05 : 1}
                                       value={Number(UNIT_META[unit].fromBase(s.w / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                                       onChange={(e) => updateShape(s.id, { w: UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM })} />
                              </div>
                              <div>
                                <label className="block text-gray-500">Alto ({UNIT_META[unit].label})</label>
                                <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                       min={unit === "m" ? 0.05 : 5} step={unit === "m" ? 0.05 : 1}
                                       value={Number(UNIT_META[unit].fromBase(s.h / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                                       onChange={(e) => updateShape(s.id, { h: UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM })} />
                              </div>
                            </div>
                          )}

                          <div className="grid grid-cols-2 gap-2">
                            <div>
                              <label className="block text-gray-500">X ({UNIT_META[unit].label})</label>
                              <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                     value={Number(UNIT_META[unit].fromBase(s.x / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                                     onChange={(e) => updateShape(s.id, { x: Math.round((UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM) / gridStepInPx) * gridStepInPx })} />
                            </div>
                            <div>
                              <label className="block text-gray-500">Y ({UNIT_META[unit].label})</label>
                              <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                     value={Number(UNIT_META[unit].fromBase(s.y / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                                     onChange={(e) => updateShape(s.id, { y: Math.round((UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM) / gridStepInPx) * gridStepInPx })} />
                            </div>
                          </div>

                          {s.type !== "text" && (
                            <div className="grid grid-cols-2 gap-2 items-center">
                              <div>
                                <label className="block text-gray-500">Color</label>
                                <input type="color" className="mt-1 h-10 w-full rounded-xl border"
                                       value={s.fill}
                                       onChange={(e) => updateShape(s.id, { fill: e.target.value })} />
                              </div>
                              <div>
                                <label className="block text-gray-500">Opacidad</label>
                                <input type="range" min={0.2} max={1} step={0.05} className="mt-1 w-full"
                                       value={s.opacity}
                                       onChange={(e) => updateShape(s.id, { opacity: Number(e.target.value) })} />
                              </div>
                            </div>
                          )}

                          <div>
                            <label className="block text-gray-500">Rotación (°)</label>
                            <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                   value={Math.round(s.rotation||0)}
                                   onChange={(e)=> updateShape(s.id, { rotation: Number(e.target.value) })} />
                          </div>

                          <button onClick={deleteSelected} className="w-full mt-2 px-3 py-2 rounded-xl bg-red-50 text-red-700 border border-red-200 hover:bg-red-100">Eliminar</button>
                        </>
                      );
                    })()}
                  </div>
                ) : (
                  // Connector controls
                  <div className="space-y-3 text-sm">
                    {(() => {
                      const c = selectedConnector; if (!c) return null;
                      return (
                        <>
                          <div className="grid grid-cols-2 gap-2">
                            <div>
                              <label className="block text-gray-500">x1 (px)</label>
                              <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                     value={c.x1} onChange={(e)=> updateConnector(c.id, { x1: Number(e.target.value) })} />
                            </div>
                            <div>
                              <label className="block text-gray-500">y1 (px)</label>
                              <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                     value={c.y1} onChange={(e)=> updateConnector(c.id, { y1: Number(e.target.value) })} />
                            </div>
                            <div>
                              <label className="block text-gray-500">x2 (px)</label>
                              <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                     value={c.x2} onChange={(e)=> updateConnector(c.id, { x2: Number(e.target.value) })} />
                            </div>
                            <div>
                              <label className="block text-gray-500">y2 (px)</label>
                              <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                     value={c.y2} onChange={(e)=> updateConnector(c.id, { y2: Number(e.target.value) })} />
                            </div>
                          </div>
                          <div className="grid grid-cols-2 gap-2">
                            <div>
                              <label className="block text-gray-500">Grosor</label>
                              <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                                     min={1} max={10} value={c.strokeWidth || 2}
                                     onChange={(e)=> updateConnector(c.id, { strokeWidth: Number(e.target.value) })} />
                            </div>
                            <div>
                              <label className="block text-gray-500">Color</label>
                              <input type="color" className="mt-1 h-10 w-full rounded-xl border"
                                     value={c.color || "#374151"}
                                     onChange={(e)=> updateConnector(c.id, { color: e.target.value })}
                                     style={{ accentColor: c.color || "#374151" }} />
                            </div>
                          </div>
                          <div className="flex items-center gap-3">
                            <label className="inline-flex items-center gap-2">
                              <input type="checkbox" checked={!!c.arrow} onChange={(e)=> updateConnector(c.id, { arrow: e.target.checked })} />
                              <span>Flecha</span>
                            </label>
                            <label className="inline-flex items-center gap-2">
                              <input type="checkbox" checked={!!c.dashed} onChange={(e)=> updateConnector(c.id, { dashed: e.target.checked })} />
                              <span>Punteada</span>
                            </label>
                          </div>
                          <button onClick={deleteSelected} className="w-full mt-2 px-3 py-2 rounded-xl bg-red-50 text-red-700 border border-red-200 hover:bg-red-100">Eliminar</button>
                        </>
                      );
                    })()}
                  </div>
                )}
              </Section>

              <Section title="Atajos">
                <ul className="text-sm text-gray-600 list-disc pl-5 space-y-1">
                  <li><kbd className="px-1 border rounded">Shift + arrastrar</kbd> para mover el lienzo</li>
                  <li>Arrastra el círculo superior para <strong>rotar</strong> una figura</li>
                  <li>Arrastra los nodos de los conectores para mover los extremos</li>
                </ul>
              </Section>
            </div>

            <div className="relative overflow-hidden">
              <div ref={canvasRef} className="absolute inset-0" style={gridBackground} onMouseDown={onMouseDownCanvas}>
                {/* layers */}
                <div className="absolute" style={{ transform: `translate(${pan.x}px, ${pan.y}px)` }} onMouseDown={()=>{}}>
                  {/* Connectors behind shapes */}
                  <ConnectorsLayer
                    connectors={connectors.map(c => ({...c, color: c.color}))}
                    selectedId={selectedKind==="connector"?selectedId:null}
                    onSelect={(id)=>{ setSelectedId(id); setSelectedKind("connector"); }}
                    onDragEndpointStart={onDragEndpointStart}
                  />
                  {/* Shapes */}
                  {shapes.map((sh) => (
                    <Shape
                      key={sh.id}
                      shape={sh}
                      selected={selectedKind==="shape" && selectedId === sh.id}
                      unitLabel={UNIT_META[unit].label}
                      sizePxToUnit={(px) => UNIT_META[unit].fromBase(px / scalePxPerM)}
                      onMouseDown={(e, mode) => onMouseDownShape(e, sh.id, mode)}
                      onRotateDown={onRotateDown}
                    />
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
